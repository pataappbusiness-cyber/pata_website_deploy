// === liquid-shader.js ===
;(function(){
/**
 * PATA Liquid Shader Background
 * Adapted from GLSL shader with brand color integration
 * Performance optimized for web deployment
 */

class LiquidShader {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    if (!this.canvas) {
      console.error('Canvas element not found:', canvasId);
      return;
    }

    this.gl = this.canvas.getContext('webgl') || this.canvas.getContext('experimental-webgl');

    if (!this.gl) {
      console.warn('WebGL not supported, falling back to CSS gradient');
      this.canvas.style.display = 'none';
      return;
    }

    this.startTime = Date.now();
    this.animationId = null;

    // PATA Brand Colors (normalized to 0-1 range for WebGL)
    this.brandColors = {
      blue: [44/255, 101/255, 147/255],        // #2C6593 - Blue (most prominent)
      darkOrange: [219/255, 93/255, 35/255],   // #DB5D23 - Dark Orange
      lightOrange: [255/255, 200/255, 129/255] // #FFC881 - Light Orange
    };

    this.mouseX = 0.5;
    this.mouseY = 0.5;

    this.init();
  }

  init() {
    this.resizeCanvas();
    window.addEventListener('resize', () => this.resizeCanvas());

    // Add mouse tracking
    this.canvas.addEventListener('mousemove', (e) => this.handleMouseMove(e));
    this.canvas.addEventListener('mouseleave', () => this.handleMouseLeave());

    this.createShaderProgram();
    this.setupUniforms();
    this.setupGeometry();
    this.animate();
  }

  handleMouseMove(e) {
    const rect = this.canvas.getBoundingClientRect();
    this.mouseX = (e.clientX - rect.left) / rect.width;
    this.mouseY = 1.0 - (e.clientY - rect.top) / rect.height; // Invert Y for WebGL
  }

  handleMouseLeave() {
    // Smoothly return to center when mouse leaves
    this.mouseX = 0.5;
    this.mouseY = 0.5;
  }

  resizeCanvas() {
    const dpr = window.devicePixelRatio || 1;
    const displayWidth = this.canvas.clientWidth;
    const displayHeight = this.canvas.clientHeight;

    // Use full device pixel ratio for crisp rendering
    this.canvas.width = displayWidth * dpr;
    this.canvas.height = displayHeight * dpr;

    if (this.gl) {
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    }
  }

  createShaderProgram() {
    // Vertex Shader (passes coordinates to fragment shader)
    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    // Fragment Shader (PATA brand color liquid effect)
    const fragmentShaderSource = `
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec2 u_mouse;
      uniform vec3 u_color1; // #2C6593 - Blue
      uniform vec3 u_color2; // #DB5D23 - Dark Orange
      uniform vec3 u_color3; // #FFC881 - Light Orange

      void main() {
        vec2 uv = gl_FragCoord.xy / u_resolution.xy;

        // Calculate distance from mouse for interaction
        float mouseInfluence = distance(uv, u_mouse);
        mouseInfluence = 1.0 - smoothstep(0.0, 0.5, mouseInfluence);

        float d = -u_time * 0.5 + mouseInfluence * 2.0;
        float a = 0.0;

        // Simplified liquid motion with mouse influence
        for (float i = 0.0; i < 8.0; i += 1.0) {
          a += cos(i - d - a * uv.x + mouseInfluence);
          d += sin(uv.y * i + a);
        }

        d += u_time * 0.5;

        // Create mixing values
        float mix1 = sin(d + a) * 0.5 + 0.5;
        float mix2 = cos(d - a) * 0.5 + 0.5;

        // Brighten the orange colors
        vec3 brightOrange1 = u_color2 * 1.3;
        vec3 brightOrange2 = u_color3 * 1.4;

        // Blend the three colors with brighter oranges
        vec3 tempColor = mix(u_color1, brightOrange1, mix1 * 0.4);
        vec3 finalColor = mix(tempColor, brightOrange2, mix2 * 0.3);

        // Apply 25% black overlay to darken
        finalColor = finalColor * 0.75;

        gl_FragColor = vec4(finalColor, 1.0);
      }
    `;

    const vertexShader = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);
    const fragmentShader = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);

    this.program = this.gl.createProgram();
    this.gl.attachShader(this.program, vertexShader);
    this.gl.attachShader(this.program, fragmentShader);
    this.gl.linkProgram(this.program);

    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
      console.error('Shader program failed to link:', this.gl.getProgramInfoLog(this.program));
      return;
    }

    console.log('Shader program linked successfully');
    this.gl.useProgram(this.program);
  }

  compileShader(source, type) {
    const shader = this.gl.createShader(type);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
      console.error('Shader source:', source);
      this.gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  setupUniforms() {
    // Get uniform locations
    this.uniforms = {
      resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
      time: this.gl.getUniformLocation(this.program, 'u_time'),
      mouse: this.gl.getUniformLocation(this.program, 'u_mouse'),
      color1: this.gl.getUniformLocation(this.program, 'u_color1'),
      color2: this.gl.getUniformLocation(this.program, 'u_color2'),
      color3: this.gl.getUniformLocation(this.program, 'u_color3')
    };

    // Set static uniforms (brand colors)
    this.gl.uniform3fv(this.uniforms.color1, this.brandColors.blue);
    this.gl.uniform3fv(this.uniforms.color2, this.brandColors.darkOrange);
    this.gl.uniform3fv(this.uniforms.color3, this.brandColors.lightOrange);
  }

  setupGeometry() {
    // Create full-screen quad
    const positions = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]);

    const buffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

    const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
    this.gl.enableVertexAttribArray(positionLocation);
    this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
  }

  animate() {
    this.animationId = requestAnimationFrame(() => this.animate());

    const currentTime = (Date.now() - this.startTime) * 0.001; // Convert to seconds

    // Update dynamic uniforms
    this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
    this.gl.uniform1f(this.uniforms.time, currentTime);
    this.gl.uniform2f(this.uniforms.mouse, this.mouseX, this.mouseY);

    // Render
    this.gl.clearColor(0, 0, 0, 0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
  }

  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }

    window.removeEventListener('resize', () => this.resizeCanvas());
    this.canvas.removeEventListener('mousemove', (e) => this.handleMouseMove(e));
    this.canvas.removeEventListener('mouseleave', () => this.handleMouseLeave());

    if (this.gl) {
      this.gl.deleteProgram(this.program);
    }
  }
}

// Initialize shaders when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  if (!prefersReducedMotion) {
    // Initialize shader instances only for canvases that exist on the page
    window.liquidShaders = {};

    const canvasIds = [
      'liquid-shader-canvas',
      'liquid-shader-canvas-joinus2',
      'liquid-shader-canvas-joinus3'
    ];

    canvasIds.forEach((canvasId) => {
      if (document.getElementById(canvasId)) {
        const key = canvasId.replace('liquid-shader-canvas-', '').replace('liquid-shader-canvas', 'header');
        window.liquidShaders[key] = new LiquidShader(canvasId);
      }
    });
  }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (window.liquidShaders) {
    Object.values(window.liquidShaders).forEach(shader => {
      if (shader) {
        shader.destroy();
      }
    });
  }
});

})();

// === scroll-to-top.js ===
;(function(){
/**
 * PATA Scroll to Top Button
 * Handles visibility, scroll progress, and smooth scrolling
 */

class ScrollToTopButton {
  constructor(smoothScroll) {
    this.button = document.getElementById('scroll-to-top-button');
    this.progressCircle = document.querySelector('.progress-ring-circle');
    this.heroSection = document.getElementById('hero');
    this.smoothScroll = smoothScroll;

    if (!this.button || !this.progressCircle || !this.heroSection) {
      console.error('Required elements not found for ScrollToTopButton');
      return;
    }

    // Calculate circle circumference for progress animation
    const radius = this.progressCircle.r.baseVal.value;
    this.circumference = radius * 2 * Math.PI;

    // Set initial stroke dash properties
    this.progressCircle.style.strokeDasharray = `${this.circumference} ${this.circumference}`;
    this.progressCircle.style.strokeDashoffset = this.circumference;

    // Bind methods
    this.handleScroll = this.handleScroll.bind(this);
    this.scrollToTop = this.scrollToTop.bind(this);

    // Initialize
    this.init();
  }

  init() {
    // Add scroll event listener with throttle
    let ticking = false;
    window.addEventListener('scroll', () => {
      if (!ticking) {
        window.requestAnimationFrame(() => {
          this.handleScroll();
          ticking = false;
        });
        ticking = true;
      }
    });

    // Add click event listener
    this.button.addEventListener('click', (e) => {
      e.preventDefault();
      e.stopPropagation();
      console.log('ðŸ” Scroll to top button clicked');
      this.scrollToTop();
    });

    // Initial check
    this.handleScroll();

    console.log('âœ… Scroll to top button initialized successfully');
  }

  handleScroll() {
    const heroHeight = this.heroSection.offsetHeight;
    const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
    const docHeight = document.documentElement.scrollHeight - document.documentElement.clientHeight;

    // Show/hide button based on scroll position
    if (scrollTop > heroHeight) {
      this.button.removeAttribute('hidden');
      this.button.classList.add('visible');
    } else {
      this.button.classList.remove('visible');
      // Delay hiding to allow fade-out animation
      setTimeout(() => {
        if (!this.button.classList.contains('visible')) {
          this.button.setAttribute('hidden', '');
        }
      }, 300);
    }

    // Calculate scroll progress (0 to 1)
    const scrollableDistance = docHeight - heroHeight;
    const scrollProgress = Math.min(
      Math.max((scrollTop - heroHeight) / scrollableDistance, 0),
      1
    );

    // Update progress circle
    this.setProgress(scrollProgress);

    // Update arrow color based on section below button
    this.updateArrowColor();
  }

  setProgress(progress) {
    // Calculate offset (inverted for clockwise animation)
    const offset = this.circumference - (progress * this.circumference);
    this.progressCircle.style.strokeDashoffset = offset;
  }

  updateArrowColor() {
    // Get button position
    const buttonRect = this.button.getBoundingClientRect();
    const buttonCenterY = buttonRect.top + buttonRect.height / 2;

    // Find element at button position
    const elementBelow = document.elementFromPoint(
      buttonRect.left + buttonRect.width / 2,
      buttonCenterY + buttonRect.height
    );

    if (!elementBelow) return;

    // Find the closest section
    const section = elementBelow.closest('section, footer');

    if (section) {
      // Define sections where arrow should be white
      const whiteSections = [
        'problem4',
        'solution1',
        'solution3',
        'joinus2',
        'joinus3'
      ];

      const isWhiteSection = whiteSections.includes(section.id) ||
                            section.tagName.toLowerCase() === 'footer';

      // Add white-arrow class for specific sections
      if (isWhiteSection) {
        this.button.classList.add('white-arrow');
      } else {
        this.button.classList.remove('white-arrow');
      }
    }
  }

  scrollToTop() {
    console.log('ðŸ“œ Scrolling to top...');

    // Use custom smooth scroll if available (same as navbar/footer)
    if (this.smoothScroll && typeof this.smoothScroll.scrollTo === 'function') {
      this.smoothScroll.scrollTo(0);
    } else {
      // Fallback to native smooth scroll
      window.scrollTo({
        top: 0,
        behavior: 'smooth'
      });
    }

    // Optional: Add haptic feedback on mobile
    if ('vibrate' in navigator) {
      navigator.vibrate(10);
    }

    // Trigger analytics event (optional)
    if (typeof gtag !== 'undefined') {
      gtag('event', 'scroll_to_top_click', {
        'event_category': 'engagement',
        'event_label': 'scroll_button'
      });
    }
  }

  destroy() {
    window.removeEventListener('scroll', this.handleScroll);
    this.button.removeEventListener('click', this.scrollToTop);
  }
}

// Initialize when DOM is ready
// Note: This is now initialized from main.js with smoothScroll instance
// Export for use in main.js (browser global)
window.ScrollToTopButton = ScrollToTopButton;

// Export for Node.js (if needed)
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ScrollToTopButton;
}

})();

// === scroll-button-shader.js ===
;(function(){
/**
 * PATA Scroll Button Liquid Shader
 * Smaller version of the liquid shader for the scroll-to-top button hover effect
 */

class ScrollButtonShader {
  constructor(canvasId) {
    this.canvas = document.getElementById(canvasId);
    if (!this.canvas) {
      console.error('Canvas element not found:', canvasId);
      return;
    }

    this.gl = this.canvas.getContext('webgl', {
      alpha: true,
      antialias: true,
      preserveDrawingBuffer: false
    }) || this.canvas.getContext('experimental-webgl', {
      alpha: true,
      antialias: true,
      preserveDrawingBuffer: false
    });

    if (!this.gl) {
      console.warn('WebGL not supported for scroll button shader');
      return;
    }

    this.startTime = Date.now();
    this.animationId = null;
    this.isVisible = false;

    // PATA Brand Colors (normalized to 0-1 range)
    this.brandColors = {
      primaryOrange: [223/255, 110/255, 57/255],
      darkBlue: [18/255, 40/255, 58/255],
      accentOrange: [219/255, 93/255, 35/255],
      lightBlue: [56/255, 123/255, 178/255]
    };

    this.init();
  }

  init() {
    this.resizeCanvas();

    // Watch for hover events on parent button
    const button = this.canvas.closest('.scroll-to-top-btn');
    if (button) {
      button.addEventListener('mouseenter', () => {
        this.isVisible = true;
        if (!this.animationId) {
          this.animate();
        }
      });

      button.addEventListener('mouseleave', () => {
        this.isVisible = false;
      });
    }

    this.createShaderProgram();
    this.setupUniforms();
    this.setupGeometry();
  }

  resizeCanvas() {
    const size = 40; // Match button size
    const dpr = Math.min(window.devicePixelRatio || 1, 2);

    this.canvas.width = size * dpr;
    this.canvas.height = size * dpr;

    if (this.gl) {
      this.gl.viewport(0, 0, this.canvas.width, this.canvas.height);
    }
  }

  createShaderProgram() {
    // Vertex Shader
    const vertexShaderSource = `
      attribute vec2 a_position;
      void main() {
        gl_Position = vec4(a_position, 0.0, 1.0);
      }
    `;

    // Fragment Shader (optimized for small size)
    const fragmentShaderSource = `
      precision mediump float;
      uniform vec2 u_resolution;
      uniform float u_time;
      uniform vec3 u_color1;
      uniform vec3 u_color2;
      uniform vec3 u_color3;
      uniform vec3 u_color4;

      void main() {
        vec2 uv = (gl_FragCoord.xy * 2.0 - u_resolution.xy) / min(u_resolution.x, u_resolution.y);

        float d = -u_time * 0.3;
        float a = 0.0;

        // Simplified liquid motion (fewer iterations for performance)
        for (float i = 0.0; i < 5.0; ++i) {
          a += cos(i - d - a * uv.x);
          d += sin(uv.y * i + a);
        }

        d += u_time * 0.3;

        // Color mixing
        vec3 col = vec3(
          cos(uv * vec2(d, a)) * 0.6 + 0.4,
          cos(a + d) * 0.5 + 0.5
        );

        col = cos(col * cos(vec3(d, a, 2.5)) * 0.5 + 0.5);

        // Blend PATA brand colors
        vec3 finalColor = mix(
          mix(u_color2, u_color4, col.r),
          mix(u_color3, u_color1, col.g),
          col.b
        );

        finalColor = finalColor * (0.9 + col.r * 0.2);

        // Add subtle vignette for circular appearance
        float dist = length(uv);
        float vignette = smoothstep(1.0, 0.6, dist);
        finalColor *= vignette;

        gl_FragColor = vec4(finalColor, vignette);
      }
    `;

    const vertexShader = this.compileShader(vertexShaderSource, this.gl.VERTEX_SHADER);
    const fragmentShader = this.compileShader(fragmentShaderSource, this.gl.FRAGMENT_SHADER);

    this.program = this.gl.createProgram();
    this.gl.attachShader(this.program, vertexShader);
    this.gl.attachShader(this.program, fragmentShader);
    this.gl.linkProgram(this.program);

    if (!this.gl.getProgramParameter(this.program, this.gl.LINK_STATUS)) {
      console.error('Shader program link failed:', this.gl.getProgramInfoLog(this.program));
      return;
    }

    this.gl.useProgram(this.program);
  }

  compileShader(source, type) {
    const shader = this.gl.createShader(type);
    this.gl.shaderSource(shader, source);
    this.gl.compileShader(shader);

    if (!this.gl.getShaderParameter(shader, this.gl.COMPILE_STATUS)) {
      console.error('Shader compilation error:', this.gl.getShaderInfoLog(shader));
      this.gl.deleteShader(shader);
      return null;
    }

    return shader;
  }

  setupUniforms() {
    this.uniforms = {
      resolution: this.gl.getUniformLocation(this.program, 'u_resolution'),
      time: this.gl.getUniformLocation(this.program, 'u_time'),
      color1: this.gl.getUniformLocation(this.program, 'u_color1'),
      color2: this.gl.getUniformLocation(this.program, 'u_color2'),
      color3: this.gl.getUniformLocation(this.program, 'u_color3'),
      color4: this.gl.getUniformLocation(this.program, 'u_color4')
    };

    // Set static uniforms
    this.gl.uniform3fv(this.uniforms.color1, this.brandColors.primaryOrange);
    this.gl.uniform3fv(this.uniforms.color2, this.brandColors.darkBlue);
    this.gl.uniform3fv(this.uniforms.color3, this.brandColors.accentOrange);
    this.gl.uniform3fv(this.uniforms.color4, this.brandColors.lightBlue);
  }

  setupGeometry() {
    const positions = new Float32Array([
      -1, -1,
       1, -1,
      -1,  1,
       1,  1
    ]);

    const buffer = this.gl.createBuffer();
    this.gl.bindBuffer(this.gl.ARRAY_BUFFER, buffer);
    this.gl.bufferData(this.gl.ARRAY_BUFFER, positions, this.gl.STATIC_DRAW);

    const positionLocation = this.gl.getAttribLocation(this.program, 'a_position');
    this.gl.enableVertexAttribArray(positionLocation);
    this.gl.vertexAttribPointer(positionLocation, 2, this.gl.FLOAT, false, 0, 0);
  }

  animate() {
    if (!this.isVisible) {
      this.animationId = null;
      return;
    }

    this.animationId = requestAnimationFrame(() => this.animate());

    const currentTime = (Date.now() - this.startTime) * 0.001;

    // Update uniforms
    this.gl.uniform2f(this.uniforms.resolution, this.canvas.width, this.canvas.height);
    this.gl.uniform1f(this.uniforms.time, currentTime);

    // Render
    this.gl.clearColor(0, 0, 0, 0);
    this.gl.clear(this.gl.COLOR_BUFFER_BIT);
    this.gl.drawArrays(this.gl.TRIANGLE_STRIP, 0, 4);
  }

  destroy() {
    if (this.animationId) {
      cancelAnimationFrame(this.animationId);
    }

    if (this.gl) {
      this.gl.deleteProgram(this.program);
    }
  }
}

// Initialize when DOM is ready
document.addEventListener('DOMContentLoaded', () => {
  // Check for reduced motion preference
  const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

  if (!prefersReducedMotion) {
    window.scrollButtonShader = new ScrollButtonShader('scroll-button-shader-canvas');
    console.log('ðŸŽ¨ Scroll button shader initialized');
  }
});

// Cleanup on page unload
window.addEventListener('beforeunload', () => {
  if (window.scrollButtonShader) {
    window.scrollButtonShader.destroy();
  }
});

})();

// === faq.js ===
;(function(){
/* ============================================
   FAQ ACCORDION - JAVASCRIPT
   Figma: https://www.figma.com/design/foywvD3Djh1yzshKk4Fwft/PATA-WEBSITE?node-id=337-3380&m=dev
   ============================================ */

(function() {
  'use strict';

  // Wait for DOM to be fully loaded
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initFAQ);
  } else {
    initFAQ();
  }

  function initFAQ() {
    const faqItems = document.querySelectorAll('.faq-item');

    if (!faqItems || faqItems.length === 0) {
      console.warn('FAQ: No FAQ items found');
      return;
    }

    faqItems.forEach((item, index) => {
      const button = item.querySelector('.faq-question-button');
      const answer = item.querySelector('.faq-answer');

      if (!button || !answer) {
        console.warn(`FAQ: Missing button or answer in item ${index}`);
        return;
      }

      // Set up ARIA attributes
      const itemId = `faq-item-${index}`;
      const buttonId = `faq-button-${index}`;
      const answerId = `faq-answer-${index}`;

      button.setAttribute('id', buttonId);
      button.setAttribute('aria-expanded', 'false');
      button.setAttribute('aria-controls', answerId);

      answer.setAttribute('id', answerId);
      answer.setAttribute('role', 'region');
      answer.setAttribute('aria-labelledby', buttonId);

      // Click event
      button.addEventListener('click', function() {
        toggleFAQItem(item);
      });

      // Keyboard navigation
      button.addEventListener('keydown', function(e) {
        // Enter or Space to toggle
        if (e.key === 'Enter' || e.key === ' ') {
          e.preventDefault();
          toggleFAQItem(item);
        }
        // Arrow Down - Move to next FAQ
        else if (e.key === 'ArrowDown') {
          e.preventDefault();
          focusNextFAQ(index, faqItems);
        }
        // Arrow Up - Move to previous FAQ
        else if (e.key === 'ArrowUp') {
          e.preventDefault();
          focusPreviousFAQ(index, faqItems);
        }
        // Home - Move to first FAQ
        else if (e.key === 'Home') {
          e.preventDefault();
          faqItems[0].querySelector('.faq-question-button').focus();
        }
        // End - Move to last FAQ
        else if (e.key === 'End') {
          e.preventDefault();
          faqItems[faqItems.length - 1].querySelector('.faq-question-button').focus();
        }
      });
    });

    console.log('FAQ: Initialized successfully with', faqItems.length, 'items');
  }

  /**
   * Toggle FAQ item open/close
   */
  function toggleFAQItem(item) {
    const button = item.querySelector('.faq-question-button');
    const answer = item.querySelector('.faq-answer');
    const isActive = item.classList.contains('active');

    if (isActive) {
      // Close the item
      closeFAQItem(item);
    } else {
      // Optional: Close all other items (uncomment to enable one-at-a-time behavior)
      // closeAllFAQItems();

      // Open the item
      openFAQItem(item);
    }
  }

  /**
   * Open a specific FAQ item
   */
  function openFAQItem(item) {
    const button = item.querySelector('.faq-question-button');
    const answer = item.querySelector('.faq-answer');

    item.classList.add('active');
    button.setAttribute('aria-expanded', 'true');

    // Set a generous max-height that will fit any answer
    answer.style.maxHeight = '800px';
  }

  /**
   * Close a specific FAQ item
   */
  function closeFAQItem(item) {
    const button = item.querySelector('.faq-question-button');
    const answer = item.querySelector('.faq-answer');

    item.classList.remove('active');
    button.setAttribute('aria-expanded', 'false');
    answer.style.maxHeight = '0';
  }

  /**
   * Close all FAQ items
   */
  function closeAllFAQItems() {
    const faqItems = document.querySelectorAll('.faq-item');
    faqItems.forEach(item => {
      closeFAQItem(item);
    });
  }

  /**
   * Focus next FAQ item
   */
  function focusNextFAQ(currentIndex, faqItems) {
    const nextIndex = (currentIndex + 1) % faqItems.length;
    faqItems[nextIndex].querySelector('.faq-question-button').focus();
  }

  /**
   * Focus previous FAQ item
   */
  function focusPreviousFAQ(currentIndex, faqItems) {
    const prevIndex = (currentIndex - 1 + faqItems.length) % faqItems.length;
    faqItems[prevIndex].querySelector('.faq-question-button').focus();
  }

  // Recalculate max-height on window resize for active items
  let resizeTimer;
  window.addEventListener('resize', function() {
    clearTimeout(resizeTimer);
    resizeTimer = setTimeout(function() {
      const activeItems = document.querySelectorAll('.faq-item.active');
      activeItems.forEach(item => {
        const answer = item.querySelector('.faq-answer');
        if (answer) {
          answer.style.maxHeight = '800px';
        }
      });
    }, 250);
  });

})();

})();

// === reservar.js ===
;(function(){
/* ============================================
   SECTION 14: RESERVAR O LUGAR - JavaScript
   Form validation, submission, and image carousel
   Version: 15.0 - No-flicker counter
   
   CHANGES v15.0:
   âœ… Counter hidden until real value arrives (no 500â†’499 flicker)
   âœ… Smooth fade-in when real value loads
   âœ… fetch-based counter (JSONP removed â€” blocked by CSP)
   âœ… Post-submission updates from server response directly
   ============================================ */

'use strict';

/* ============================================
   CONFIGURATION
   ============================================ */

const RESERVAR_CONFIG = {
  GOOGLE_SCRIPT_URL: 'https://script.google.com/macros/s/AKfycbxKnC4L28gsXZUdb2f8UtZ581uLHKTdPtfHRc7vgtprxvTkw973EFxvR3WVAueuq0VT/exec',
  COUNT_ACTION_URL: 'https://script.google.com/macros/s/AKfycbxKnC4L28gsXZUdb2f8UtZ581uLHKTdPtfHRc7vgtprxvTkw973EFxvR3WVAueuq0VT/exec',

  MAX_SPOTS: 500,
  CAROUSEL_INTERVAL: 5000,
  DEBUG_MODE: false
};

/* ============================================
   COUNTER STATE
   ============================================ */

let _pataCounterLoaded = false;
let _pataCounterCache = null;

/* ============================================
   FETCH COUNTER FROM SERVER
   ============================================ */

function fetchCounterFromServer() {
  const url = RESERVAR_CONFIG.COUNT_ACTION_URL +
    '?action=getCount&_t=' + Date.now();

  return fetch(url, { redirect: 'follow' })
    .then(function(response) {
      if (!response.ok) throw new Error('HTTP ' + response.status);
      return response.text();
    })
    .then(function(text) {
      var jsonStr = text.trim();

      // Strip JSONP wrapper if present
      var jsonpMatch = jsonStr.match(/^[a-zA-Z_$][a-zA-Z0-9_$]*\s*\((.+)\)\s*;?\s*$/s);
      if (jsonpMatch) {
        jsonStr = jsonpMatch[1];
      }

      var data = JSON.parse(jsonStr);

      if (data && data.success) {
        var remaining = data.remaining !== undefined
          ? data.remaining
          : (RESERVAR_CONFIG.MAX_SPOTS - data.count);
        return remaining;
      }
      throw new Error('Server returned success:false');
    });
}

/* ============================================
   EARLY COUNTER PRELOAD
   ============================================ */

(function preloadCounter() {
  fetchCounterFromServer()
    .then(function(remaining) {
      _pataCounterCache = remaining;
      _pataCounterLoaded = true;
      applyCounterToDOM(remaining);
      console.log('ðŸ“Š Preload counter loaded:', remaining);
      if (remaining <= 0 && !RESERVAR_CONFIG.DEBUG_MODE) showListaCheia();
    })
    .catch(function(err) {
      console.warn('âš ï¸ Preload counter failed:', err.message);
    });
})();

/* ============================================
   APPLY COUNTER TO DOM
   Sets value + reveals the counter line with fade-in
   ============================================ */

function applyCounterToDOM(count) {
  _pataCounterCache = count;
  _pataCounterLoaded = true;

  var el = document.getElementById('remainingSpots');
  if (!el) return;

  el.textContent = count;

  // Reveal the parent <p> counter line
  var counterLine = el.closest('.reservar-counter');
  if (counterLine) {
    counterLine.style.opacity = '1';
  }
}

/* ============================================
   IMAGE CAROUSEL
   ============================================ */

class ReservarCarousel {
  constructor() {
    this.images = document.querySelectorAll('.reservar-carousel-image');
    this.currentIndex = 0;
    this.intervalId = null;
    if (this.images.length > 0) this.init();
  }

  init() {
    this.intervalId = setInterval(() => this.nextImage(), RESERVAR_CONFIG.CAROUSEL_INTERVAL);
    console.log('ðŸŽ  Reservar carousel initialized');
  }

  nextImage() {
    this.images[this.currentIndex].classList.remove('active');
    this.currentIndex = (this.currentIndex + 1) % this.images.length;
    setTimeout(() => {
      this.images[this.currentIndex].classList.add('active');
    }, 500);
  }

  destroy() {
    if (this.intervalId) clearInterval(this.intervalId);
  }
}

/* ============================================
   FORM VALIDATION
   ============================================ */

class ReservarFormValidator {
  constructor(formId) {
    this.form = document.getElementById(formId);
    if (!this.form) return;

    this.fields = {
      nome: document.getElementById('reservarNome'),
      email: document.getElementById('reservarEmail'),
      distrito: document.getElementById('reservarDistrito'),
      animal: document.getElementById('reservarAnimal'),
      privacy: document.getElementById('reservarPrivacy')
    };

    this.init();
  }

  init() {
    Object.values(this.fields).forEach(field => {
      if (field) {
        field.addEventListener('blur', () => this.validateField(field));
        field.addEventListener('input', () => this.clearFieldError(field));
      }
    });
    console.log('âœ… Reservar form validation initialized');
  }

  validateField(field) {
    const fieldId = field.id.replace('reservar', '').toLowerCase();
    const value = field.value.trim();
    let isValid = true;
    let errorMessage = '';

    switch (fieldId) {
      case 'nome':
        if (!value) { isValid = false; errorMessage = 'Tem de inserir o nome.'; }
        break;
      case 'email':
        if (!value || !this.isValidEmail(value)) { isValid = false; errorMessage = 'Email invÃ¡lido.'; }
        break;
      case 'distrito':
        if (!value) { isValid = false; errorMessage = 'Selecione um distrito.'; }
        break;
      case 'animal':
        if (!value) { isValid = false; errorMessage = 'Selecione uma opÃ§Ã£o.'; }
        break;
      case 'privacy':
        if (!field.checked) { isValid = false; errorMessage = 'Tem de aceitar a PolÃ­tica de Privacidade.'; }
        break;
    }

    if (!isValid) {
      this.showFieldError(field, errorMessage);
    } else {
      this.clearFieldError(field);
    }
    return isValid;
  }

  validateForm() {
    let isValid = true;
    Object.values(this.fields).forEach(field => {
      if (field && !this.validateField(field)) isValid = false;
    });
    return isValid;
  }

  showFieldError(field, message) {
    field.classList.add('error');
    field.setAttribute('aria-invalid', 'true');
    const el = document.getElementById(`${field.id}Error`);
    if (el) { el.textContent = message; el.classList.add('show'); }
  }

  clearFieldError(field) {
    field.classList.remove('error');
    field.setAttribute('aria-invalid', 'false');
    const el = document.getElementById(`${field.id}Error`);
    if (el) el.classList.remove('show');
  }

  isValidEmail(email) {
    return /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(email);
  }

  resetForm() {
    this.form.reset();
    Object.values(this.fields).forEach(field => {
      if (field) this.clearFieldError(field);
    });
  }
}

/* ============================================
   FORM SUBMISSION
   ============================================ */

class ReservarFormSubmitter {
  constructor(formId, validator) {
    this.form = document.getElementById(formId);
    this.validator = validator;
    this.submitButton = document.getElementById('reservarSubmitBtn');
    this.recaptchaReady = false;
    if (!this.form) return;
    this.init();
    this.initRecaptcha();
  }

  initRecaptcha() {
    const check = () => {
      if (typeof grecaptcha !== 'undefined' && grecaptcha.ready) {
        grecaptcha.ready(() => {
          this.recaptchaReady = true;
          console.log('âœ… reCAPTCHA ready');
        });
      } else {
        setTimeout(check, 100);
      }
    };
    check();
  }

  init() {
    this.form.addEventListener('submit', (e) => this.handleSubmit(e));
    console.log('âœ… Reservar form submission initialized');
  }

  async handleSubmit(e) {
    e.preventDefault();
    if (!this.validator.validateForm()) return;

    if (!this.recaptchaReady) {
      alert('Por favor, aguarde enquanto o reCAPTCHA estÃ¡ a carregar...');
      return;
    }

    this.submitButton.disabled = true;
    this.submitButton.textContent = 'A enviar...';

    try {
      await new Promise((resolve) => grecaptcha.ready(resolve));

      const token = await grecaptcha.execute(
        '6Le6-2EsAAAAAC35zcOC3-2jVhmztQL_yMNh5YEb',
        { action: 'waitlist_signup' }
      );

      const formData = {
        nome: document.getElementById('reservarNome').value.trim(),
        email: document.getElementById('reservarEmail').value.trim(),
        distrito: document.getElementById('reservarDistrito').value,
        animal: document.getElementById('reservarAnimal').value,
        marketing: document.getElementById('reservarMarketing').checked ? 'Sim' : 'NÃ£o',
        timestamp: new Date().toISOString(),
        'g-recaptcha-response': token
      };

      const result = await this.submitToGoogleScript(formData);

      if (result.success) {
        this.showSuccessModal();
        this.validator.resetForm();

        // Update counter immediately from server response
        if (result.remaining !== undefined) {
          applyCounterToDOM(result.remaining);
          console.log('ðŸ“Š Counter updated from response:', result.remaining);
        } else {
          setTimeout(() => loadRemainingSpots(), 2000);
        }
      } else {
        alert(result.message || 'Ocorreu um erro. Por favor, tente novamente.');
        console.error('âŒ Server error:', result.message);
      }
    } catch (error) {
      console.error('âŒ Submission error:', error);
      alert('Ocorreu um erro ao enviar o formulÃ¡rio. Por favor, tente novamente.');
    } finally {
      this.submitButton.disabled = false;
      this.submitButton.textContent = 'Garantir PreÃ§o de Fundador (â‚¬7,99/mÃªs)';
    }
  }

  /**
   * Submit to Google Apps Script via text/plain fetch (no CORS preflight).
   */
  async submitToGoogleScript(formData) {
    const jsonString = JSON.stringify(formData);
    const scriptUrl = RESERVAR_CONFIG.GOOGLE_SCRIPT_URL;

    // â”€â”€ ATTEMPT 1: fetch with text/plain â”€â”€
    try {
      console.log('ðŸ“¨ Attempt 1: fetch with text/plain (no preflight)...');

      const response = await fetch(scriptUrl, {
        method: 'POST',
        body: jsonString,
        headers: { 'Content-Type': 'text/plain;charset=utf-8' },
        redirect: 'follow'
      });

      if (response.ok) {
        const text = await response.text();
        console.log('ðŸ“¦ Raw response:', text);

        try {
          const result = JSON.parse(text);
          console.log('âœ… Attempt 1 succeeded:', result);
          return result;
        } catch (parseErr) {
          console.warn('âš ï¸ Response not JSON, but request succeeded');
          return { success: true, message: 'SubmissÃ£o enviada.' };
        }
      }

      console.warn('âš ï¸ Attempt 1 status:', response.status);

    } catch (err) {
      console.warn('âš ï¸ Attempt 1 failed:', err.message);
    }

    // â”€â”€ ATTEMPT 2: no-cors POST + fetch count verification â”€â”€
    try {
      console.log('ðŸ“¨ Attempt 2: no-cors + fetch count verification...');

      let countBefore = -1;
      try {
        const remaining = await fetchCounterFromServer();
        countBefore = RESERVAR_CONFIG.MAX_SPOTS - remaining;
        console.log('ðŸ“Š Count before:', countBefore);
      } catch (e) {
        console.warn('âš ï¸ Pre-count failed');
      }

      await fetch(scriptUrl, {
        method: 'POST',
        body: jsonString,
        mode: 'no-cors'
      });

      console.log('â³ Waiting 4s for GAS...');
      await new Promise(r => setTimeout(r, 4000));

      try {
        const remainingAfter = await fetchCounterFromServer();
        const countAfter = RESERVAR_CONFIG.MAX_SPOTS - remainingAfter;
        console.log('ðŸ“Š Count after:', countAfter);

        if (countBefore >= 0 && countAfter > countBefore) {
          console.log('âœ… Verified: count went from', countBefore, 'to', countAfter);
          return {
            success: true,
            message: 'SubmissÃ£o bem-sucedida!',
            remaining: remainingAfter
          };
        } else if (countBefore >= 0 && countAfter === countBefore) {
          return {
            success: false,
            message: 'O email jÃ¡ estÃ¡ na lista ou ocorreu um erro de validaÃ§Ã£o. Tente com outro email.'
          };
        }
      } catch (e) {
        console.warn('âš ï¸ Post-count verification failed');
      }

      return { success: true, message: 'SubmissÃ£o enviada.' };

    } catch (err) {
      console.error('âŒ All attempts failed:', err);
      throw err;
    }
  }

  showSuccessModal() {
    const modal = document.getElementById('reservarSuccessModal');
    if (!modal) return;
    modal.classList.add('show');
    modal.setAttribute('aria-hidden', 'false');
    const focusable = modal.querySelectorAll('button, [href], input, select, textarea, [tabindex]:not([tabindex="-1"])');
    if (focusable.length > 0) focusable[0].focus();
    setTimeout(() => this.closeModal(), 5000);
  }

  closeModal() {
    const modal = document.getElementById('reservarSuccessModal');
    if (!modal) return;
    modal.classList.remove('show');
    modal.setAttribute('aria-hidden', 'true');
  }
}

/* ============================================
   MODAL FUNCTIONS (Global)
   ============================================ */

function closeReservarModal() {
  const modal = document.getElementById('reservarSuccessModal');
  if (!modal) return;
  modal.classList.remove('show');
  modal.setAttribute('aria-hidden', 'true');
}

window.addEventListener('click', function(e) {
  const modal = document.getElementById('reservarSuccessModal');
  if (e.target === modal) closeReservarModal();
});

window.addEventListener('keydown', function(e) {
  if (e.key === 'Escape') closeReservarModal();
});

/* ============================================
   REMAINING SPOTS COUNTER
   ============================================ */

function loadRemainingSpots() {
  if (_pataCounterLoaded) return;

  fetchCounterFromServer()
    .then(function(remaining) {
      applyCounterToDOM(remaining);
      console.log('ðŸ“Š Spots remaining (retry):', remaining);
      if (remaining <= 0 && !RESERVAR_CONFIG.DEBUG_MODE) showListaCheia();
    })
    .catch(function(err) {
      console.warn('âš ï¸ Counter retry failed:', err.message);
      // After 10s total, show 500 as final fallback
      setTimeout(function() {
        if (!_pataCounterLoaded) {
          applyCounterToDOM(RESERVAR_CONFIG.MAX_SPOTS);
          console.warn('âš ï¸ Using fallback: 500');
        }
      }, 7000);
    });
}

function showListaCheia() {
  const main = document.getElementById('reservarMainContent');
  const cheia = document.getElementById('reservarListaCheia');
  if (main) main.style.display = 'none';
  if (cheia) cheia.style.display = 'flex';
}

/* ============================================
   INITIALIZE
   ============================================ */

document.addEventListener('DOMContentLoaded', () => {
  // Hide counter line until real value arrives
  var counterLine = document.querySelector('.reservar-counter');
  if (counterLine && !_pataCounterLoaded) {
    counterLine.style.opacity = '0';
    counterLine.style.transition = 'opacity 0.4s ease';
  }

  // Apply cached value if preload already returned
  if (_pataCounterLoaded && _pataCounterCache !== null) {
    applyCounterToDOM(_pataCounterCache);
    console.log('ðŸ“Š Counter from preload cache:', _pataCounterCache);
  } else {
    // Preload still pending â€” fire backup
    console.log('â³ Preload not ready, firing backup fetch...');
    loadRemainingSpots();
  }

  const carousel = new ReservarCarousel();
  const validator = new ReservarFormValidator('reservarForm');
  const submitter = new ReservarFormSubmitter('reservarForm', validator);
  console.log('ðŸ¾ Reservar section initialized');
  window.addEventListener('beforeunload', () => { if (carousel) carousel.destroy(); });
});
})();

// === main.js ===
;(function(){
/* ============================================
   PATA WEBSITE - MAIN JAVASCRIPT
   Version: 4.0 (PREVC)
   ============================================ */

'use strict';

/* ============================================
   NAVBAR - SCROLL & MOBILE TOGGLE
   ============================================ */

class Navbar {
  constructor() {
    this.navbar = document.querySelector('.navbar');
    this.navbarToggle = document.getElementById('navbarToggle');
    this.navbarLinks = document.getElementById('navbar-links');

    if (this.navbar) {
      this.init();
    }
  }

  init() {
    // Scroll effect
    window.addEventListener('scroll', () => this.handleScroll());

    // Mobile toggle
    if (this.navbarToggle && this.navbarLinks) {
      this.navbarToggle.addEventListener('click', () => this.toggleMobileMenu());
    }

    // Close menu on link click (mobile)
    const links = this.navbarLinks.querySelectorAll('.navbar-link');
    links.forEach(link => {
      link.addEventListener('click', () => {
        if (window.innerWidth <= 768) {
          this.closeMobileMenu();
        }
      });
    });
  }

  handleScroll() {
    if (window.scrollY > 50) {
      this.navbar.classList.add('scrolled');
    } else {
      this.navbar.classList.remove('scrolled');
    }
  }

  toggleMobileMenu() {
    this.navbarToggle.classList.toggle('active');
    this.navbarLinks.classList.toggle('active');

    // Prevent body scroll when menu is open
    if (this.navbarLinks.classList.contains('active')) {
      document.body.style.overflow = 'hidden';
    } else {
      document.body.style.overflow = '';
    }
  }

  closeMobileMenu() {
    this.navbarToggle.classList.remove('active');
    this.navbarLinks.classList.remove('active');
    document.body.style.overflow = '';
  }
}

/* ============================================
   SECTION 1: HEADER - Parallax Mouse Effect
   Figma: https://www.figma.com/design/foywvD3Djh1yzshKk4Fwft/PATA-WEBSITE?node-id=337-2915
   ============================================ */

class HeaderParallax {
  constructor() {
    this.header = document.querySelector('.header-section');
    this.parallaxElements = document.querySelectorAll('[data-parallax]');

    // Smooth animation properties
    this.mouseX = 0;
    this.mouseY = 0;
    this.targetX = 0;
    this.targetY = 0;
    this.ease = 0.12; // Lower = smoother (0.05-0.15 range)
    this.rafId = null;
    this.isActive = false;

    // Store current positions for each element
    this.elementPositions = new Map();

    if (this.header && this.parallaxElements.length > 0) {
      this.init();
    }
  }

  init() {
    // Only enable parallax on devices with pointer (not touch)
    if (window.matchMedia('(pointer: fine)').matches) {
      // Initialize element positions
      this.parallaxElements.forEach(element => {
        this.elementPositions.set(element, { currentX: 0, currentY: 0, targetX: 0, targetY: 0 });
      });

      this.header.addEventListener('mousemove', (e) => this.handleMouseMove(e));

      // Reset position when mouse leaves
      this.header.addEventListener('mouseleave', () => this.resetPositions());

      // Start animation loop
      this.isActive = true;
      this.animate();
    }
  }

  handleMouseMove(e) {
    const { clientX, clientY } = e;
    const { innerWidth, innerHeight } = window;

    // Calculate mouse position relative to center (-1 to 1)
    this.targetX = (clientX / innerWidth - 0.5) * 2;
    this.targetY = (clientY / innerHeight - 0.5) * 2;
  }

  animate() {
    if (!this.isActive) return;

    // Smoothly interpolate mouse position
    this.mouseX += (this.targetX - this.mouseX) * this.ease;
    this.mouseY += (this.targetY - this.mouseY) * this.ease;

    // Update each parallax element
    this.parallaxElements.forEach(element => {
      const speed = parseFloat(element.dataset.parallax) || 0.3;
      const positions = this.elementPositions.get(element);

      // Calculate target positions
      positions.targetX = this.mouseX * 50 * speed;
      positions.targetY = this.mouseY * 50 * speed;

      // Smoothly interpolate element position
      positions.currentX += (positions.targetX - positions.currentX) * this.ease;
      positions.currentY += (positions.targetY - positions.currentY) * this.ease;

      // Apply transformation
      element.style.transform = `translate(${positions.currentX}px, ${positions.currentY}px)`;
    });

    // Continue animation loop
    this.rafId = requestAnimationFrame(() => this.animate());
  }

  resetPositions() {
    // Smoothly return to center
    this.targetX = 0;
    this.targetY = 0;
  }

  destroy() {
    this.isActive = false;
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
  }
}

/* ============================================
   MOUSE HIGHLIGHT EFFECT - INTERATIVIDADE
   ============================================ */

class MouseHighlight {
  constructor() {
    this.header = document.querySelector('.header-section');
    this.highlight = document.querySelector('.mouse-highlight');

    // Performance optimization
    this.rafId = null;
    this.mouseX = 0;
    this.mouseY = 0;
    this.isActive = false;
    this.throttleDelay = 16; // ~60fps
    this.lastUpdate = 0;

    if (this.header && this.highlight) {
      this.init();
    }
  }

  init() {
    // Mouse enter - ativa o efeito
    this.header.addEventListener('mouseenter', () => {
      this.isActive = true;
      this.highlight.style.opacity = '1';
    });

    // Mouse leave - desativa o efeito
    this.header.addEventListener('mouseleave', () => {
      this.isActive = false;
      this.highlight.style.opacity = '0';
      if (this.rafId) {
        cancelAnimationFrame(this.rafId);
        this.rafId = null;
      }
    });

    // Mouse move - atualiza posiÃ§Ã£o com throttling
    this.header.addEventListener('mousemove', (e) => {
      const now = Date.now();
      if (now - this.lastUpdate < this.throttleDelay) {
        return; // Skip se muito rÃ¡pido
      }

      this.lastUpdate = now;
      this.mouseX = e.clientX;
      this.mouseY = e.clientY;

      // Usa requestAnimationFrame para performance
      if (!this.rafId && this.isActive) {
        this.rafId = requestAnimationFrame(() => this.updatePosition());
      }
    });
  }

  updatePosition() {
    // Calcula posiÃ§Ã£o relativa ao header
    const rect = this.header.getBoundingClientRect();
    const x = this.mouseX - rect.left;
    const y = this.mouseY - rect.top;

    // Converte para percentagem
    const xPercent = (x / rect.width) * 100;
    const yPercent = (y / rect.height) * 100;

    // Atualiza CSS variables (melhor performance)
    this.highlight.style.setProperty('--mouse-x', `${xPercent}%`);
    this.highlight.style.setProperty('--mouse-y', `${yPercent}%`);

    // Reset RAF id
    this.rafId = null;
  }

  // Cleanup method
  destroy() {
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
  }
}

/* ============================================
   DRAGGABLE ELEMENT - Interactive Bone
   ============================================ */

class DraggableElement {
  constructor() {
    this.element = document.getElementById('draggableElement');
    if (!this.element) return;

    this.isDragging = false;
    this.currentX = 0;
    this.currentY = 0;
    this.initialX = 0;
    this.initialY = 0;
    this.xOffset = 0;
    this.yOffset = 0;

    this.init();
  }

  init() {
    // Mouse events
    this.element.addEventListener('mousedown', (e) => this.dragStart(e));
    document.addEventListener('mousemove', (e) => this.drag(e));
    document.addEventListener('mouseup', (e) => this.dragEnd(e));

    // Touch events
    this.element.addEventListener('touchstart', (e) => this.dragStart(e));
    document.addEventListener('touchmove', (e) => this.drag(e));
    document.addEventListener('touchend', (e) => this.dragEnd(e));

    console.log('ðŸ¦´ Draggable element initialized');
  }

  dragStart(e) {
    if (e.type === 'touchstart') {
      this.initialX = e.touches[0].clientX - this.xOffset;
      this.initialY = e.touches[0].clientY - this.yOffset;
    } else {
      this.initialX = e.clientX - this.xOffset;
      this.initialY = e.clientY - this.yOffset;
    }

    if (e.target === this.element || this.element.contains(e.target)) {
      this.isDragging = true;
    }
  }

  drag(e) {
    if (this.isDragging) {
      e.preventDefault();

      if (e.type === 'touchmove') {
        this.currentX = e.touches[0].clientX - this.initialX;
        this.currentY = e.touches[0].clientY - this.initialY;
      } else {
        this.currentX = e.clientX - this.initialX;
        this.currentY = e.clientY - this.initialY;
      }

      this.xOffset = this.currentX;
      this.yOffset = this.currentY;

      this.setTranslate(this.currentX, this.currentY);
    }
  }

  dragEnd(e) {
    this.initialX = this.currentX;
    this.initialY = this.currentY;
    this.isDragging = false;
  }

  setTranslate(xPos, yPos) {
    this.element.style.transform = `translate(${xPos}px, ${yPos}px)`;
  }
}

/* ============================================
   CONTACT BUTTON - Scroll to Contact Section
   ============================================ */

class ContactButtons {
  constructor(smoothScroll) {
    this.ctaButtons = document.querySelectorAll('.navbar-cta-button');
    this.smoothScroll = smoothScroll;

    if (this.ctaButtons.length > 0) {
      this.init();
    }
  }

  init() {
    this.ctaButtons.forEach(button => {
      button.addEventListener('click', (e) => {
        e.preventDefault();
        this.scrollToContact();
      });
    });
  }

  scrollToContact() {
    const contactSection = document.querySelector('#reservar');
    if (!contactSection) return;

    if (this.smoothScroll && typeof this.smoothScroll.scrollTo === 'function') {
      this.smoothScroll.scrollTo(contactSection.offsetTop);
    } else {
      contactSection.scrollIntoView({ behavior: 'smooth' });
    }
  }
}

/* ============================================
   SECTION 2: PROBLEM1 - LAZY LOADING VÃDEOS
   Figma: https://www.figma.com/design/foywvD3Djh1yzshKk4Fwft/PATA-WEBSITE?node-id=337-2938&m=dev
   ============================================ */

class VideoLazyLoader {
  constructor() {
    this.videos = document.querySelectorAll('video[data-lazy-video]');

    if (this.videos.length > 0) {
      this.init();
    }
  }

  init() {
    // Intersection Observer para carregar vÃ­deos quando visÃ­veis
    const options = {
      root: null,
      rootMargin: '200px',
      threshold: 0.1
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting) {
          this.loadVideo(entry.target);
          observer.unobserve(entry.target);
        }
      });
    }, options);

    this.videos.forEach(video => observer.observe(video));
  }

  loadVideo(video) {
    const sources = video.querySelectorAll('source[data-src]');

    sources.forEach(source => {
      source.src = source.dataset.src;
    });

    video.load();
    video.play();

    // Remove atributo data-lazy-video apÃ³s carregar
    video.removeAttribute('data-lazy-video');
  }
}

/* ============================================
   SECTION 2: PROBLEM1 - CARD SCROLL ANIMATIONS
   ============================================ */

class Problem1Animations {
  constructor() {
    this.section = document.querySelector('.problem1-section');
    this.greyCard = document.querySelector('.price-card-grey');
    this.orangeCard = document.querySelector('.price-card-orange');
    this.isVisible = false;

    if (this.section && this.greyCard && this.orangeCard) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showCards();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideCards();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showCards() {
    // Show both cards at the same time
    this.greyCard.classList.add('visible');
    this.orangeCard.classList.add('visible');
  }

  hideCards() {
    // Hide both cards
    this.greyCard.classList.remove('visible');
    this.orangeCard.classList.remove('visible');
  }
}

/* ============================================
   SECTION 7: SOLUTION1 - CARD SCROLL ANIMATIONS
   ============================================ */

class Solution1Animations {
  constructor() {
    this.section = document.querySelector('.solution1-section');
    this.leftCard = document.querySelector('.solution1-card-left .card-content');
    this.rightCard = document.querySelector('.solution1-card-right .card-content');
    this.isVisible = false;

    if (this.section && this.leftCard && this.rightCard) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showCards();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideCards();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showCards() {
    // Show both cards at the same time
    this.leftCard.classList.add('visible');
    this.rightCard.classList.add('visible');
  }

  hideCards() {
    // Hide both cards
    this.leftCard.classList.remove('visible');
    this.rightCard.classList.remove('visible');
  }
}

/* ============================================
   SECTION 9: SOLUTION3 - CARD SCROLL ANIMATIONS
   ============================================ */

class Solution3Animations {
  constructor() {
    this.section = document.querySelector('.solution3-section');
    this.cards = document.querySelectorAll('.solution3-card');
    this.isVisible = false;

    if (this.section && this.cards.length > 0) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showCards();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideCards();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showCards() {
    // Show all cards at the same time
    this.cards.forEach(card => {
      card.classList.add('visible');
    });
  }

  hideCards() {
    // Hide all cards
    this.cards.forEach(card => {
      card.classList.remove('visible');
    });
  }
}

/* ============================================
   SECTION 10: SOLUTION4 - CARD SCROLL ANIMATIONS
   ============================================ */

class Solution4Animations {
  constructor() {
    this.section = document.querySelector('.solution4-section');
    this.mainCard = document.querySelector('.solution4-main-card');
    this.bottomCards = document.querySelectorAll('.bottom-card');
    this.isVisible = false;

    if (this.section && (this.mainCard || this.bottomCards.length > 0)) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showCards();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideCards();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showCards() {
    // Show main card and bottom cards
    if (this.mainCard) {
      this.mainCard.classList.add('visible');
    }
    this.bottomCards.forEach(card => {
      card.classList.add('visible');
    });
  }

  hideCards() {
    // Hide main card and bottom cards
    if (this.mainCard) {
      this.mainCard.classList.remove('visible');
    }
    this.bottomCards.forEach(card => {
      card.classList.remove('visible');
    });
  }
}

/* ============================================
   SECTION 11: JOINUS1 - CARD SCROLL ANIMATIONS
   ============================================ */

class JoinUs1Animations {
  constructor() {
    this.section = document.querySelector('.joinus1-section');
    this.card1 = document.querySelector('.joinus1-card-1');
    this.card2 = document.querySelector('.joinus1-card-2');
    this.card3 = document.querySelector('.joinus1-card-3');
    this.planCard1 = document.querySelector('.bottom-plan-card-1');
    this.planCard2 = document.querySelector('.bottom-plan-card-2');
    this.planCard3 = document.querySelector('.bottom-plan-card-3');
    this.topCardsVisible = false;
    this.bottomCardsVisible = false;

    if (this.section) {
      this.init();
    }
  }

  init() {
    // Observer for top cards
    const topCardsOptions = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const topCardsObserver = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.topCardsVisible) {
          this.showTopCards();
          this.topCardsVisible = true;
        } else if (!entry.isIntersecting && this.topCardsVisible) {
          this.hideTopCards();
          this.topCardsVisible = false;
        }
      });
    }, topCardsOptions);

    if (this.card1 || this.card2 || this.card3) {
      topCardsObserver.observe(this.section);
    }

    // Observer for bottom plan cards
    const bottomCardsElement = document.querySelector('.joinus1-bottom-cards');
    if (bottomCardsElement) {
      const bottomCardsOptions = {
        root: null,
        rootMargin: '0px',
        threshold: 0.3
      };

      const bottomCardsObserver = new IntersectionObserver((entries) => {
        entries.forEach(entry => {
          if (entry.isIntersecting && !this.bottomCardsVisible) {
            this.showBottomCards();
            this.bottomCardsVisible = true;
          } else if (!entry.isIntersecting && this.bottomCardsVisible) {
            this.hideBottomCards();
            this.bottomCardsVisible = false;
          }
        });
      }, bottomCardsOptions);

      bottomCardsObserver.observe(bottomCardsElement);
    }
  }

  showTopCards() {
    // Show top three cards
    if (this.card1) {
      this.card1.classList.add('visible');
    }
    if (this.card2) {
      this.card2.classList.add('visible');
    }
    if (this.card3) {
      this.card3.classList.add('visible');
    }
  }

  hideTopCards() {
    // Hide top three cards
    if (this.card1) {
      this.card1.classList.remove('visible');
    }
    if (this.card2) {
      this.card2.classList.remove('visible');
    }
    if (this.card3) {
      this.card3.classList.remove('visible');
    }
  }

  showBottomCards() {
    // Show bottom plan cards
    if (this.planCard1) {
      this.planCard1.classList.add('visible');
    }
    if (this.planCard2) {
      this.planCard2.classList.add('visible');
    }
    if (this.planCard3) {
      this.planCard3.classList.add('visible');
    }
  }

  hideBottomCards() {
    // Hide bottom plan cards
    if (this.planCard1) {
      this.planCard1.classList.remove('visible');
    }
    if (this.planCard2) {
      this.planCard2.classList.remove('visible');
    }
    if (this.planCard3) {
      this.planCard3.classList.remove('visible');
    }
  }
}

/* ============================================
   SECTION 12: JOINUS2 - CARD SCROLL ANIMATIONS
   ============================================ */

class JoinUs2Animations {
  constructor() {
    this.section = document.querySelector('.joinus2-section');
    this.cards = document.querySelectorAll('.joinus2-cards-grid .benefit-card');
    this.warningCard = document.querySelector('.joinus2-warning-card');
    this.isVisible = false;

    if (this.section && this.cards.length > 0) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showCards();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideCards();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showCards() {
    // Show all 4 cards (first two from left, last two from right)
    this.cards.forEach(card => {
      card.classList.add('visible');
    });

    // Show warning card
    if (this.warningCard) {
      this.warningCard.classList.add('visible');
    }
  }

  hideCards() {
    // Hide all 4 cards
    this.cards.forEach(card => {
      card.classList.remove('visible');
    });

    // Hide warning card
    if (this.warningCard) {
      this.warningCard.classList.remove('visible');
    }
  }
}

/* ============================================
   SECTION 14: RESERVAR - REVEAL ANIMATIONS
   ============================================ */

class ReservarAnimations {
  constructor() {
    this.section = document.querySelector('.reservar-section');
    this.formCard = document.querySelector('.reservar-form-card');
    this.carousel = document.querySelector('.reservar-image-carousel');
    this.infoCards = document.querySelectorAll('.reservar-info-card');
    this.isVisible = false;

    if (this.section) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showElements();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideElements();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showElements() {
    // Show form card from left
    if (this.formCard) {
      this.formCard.classList.add('visible');
    }

    // Show carousel from right
    if (this.carousel) {
      this.carousel.classList.add('visible');
    }

    // Show info cards from bottom
    this.infoCards.forEach(card => {
      card.classList.add('visible');
    });
  }

  hideElements() {
    // Hide form card
    if (this.formCard) {
      this.formCard.classList.remove('visible');
    }

    // Hide carousel
    if (this.carousel) {
      this.carousel.classList.remove('visible');
    }

    // Hide info cards
    this.infoCards.forEach(card => {
      card.classList.remove('visible');
    });
  }
}

/* ============================================
   SECTION 1: HEADER - REVEAL ANIMATIONS
   ============================================ */

class HeaderAnimations {
  constructor() {
    this.section = document.querySelector('.header-section');
    this.headerContent = document.querySelector('.header-content');
    this.pillLeftTop = document.querySelector('.pill-left-top');
    this.pillLeftBottom = document.querySelector('.pill-left-bottom');
    this.pillRightTop = document.querySelector('.pill-right-top');
    this.pillRightBottom = document.querySelector('.pill-right-bottom');
    this.mockupCenter = document.querySelector('.mockup-center');
    this.isVisible = false;

    if (this.section) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.1
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showElements();
          this.isVisible = true;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showElements() {
    // Show header content
    if (this.headerContent) {
      this.headerContent.classList.add('visible');
    }

    // Show left pills
    if (this.pillLeftTop) {
      this.pillLeftTop.classList.add('visible');
    }
    if (this.pillLeftBottom) {
      this.pillLeftBottom.classList.add('visible');
    }

    // Show right pills
    if (this.pillRightTop) {
      this.pillRightTop.classList.add('visible');
    }
    if (this.pillRightBottom) {
      this.pillRightBottom.classList.add('visible');
    }

    // Show center mockup
    if (this.mockupCenter) {
      this.mockupCenter.classList.add('visible');
    }
  }
}

/* ============================================
   SECTION 15: JOINUS3 - STAT CARDS REVEAL ANIMATIONS
   ============================================ */

class JoinUs3Animations {
  constructor() {
    this.section = document.querySelector('.joinus3-section');
    this.statCards = document.querySelectorAll('.joinus3-stat-card');
    this.isVisible = false;

    if (this.section && this.statCards.length > 0) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showCards();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideCards();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showCards() {
    this.statCards.forEach(card => {
      card.classList.add('visible');
    });
  }

  hideCards() {
    this.statCards.forEach(card => {
      card.classList.remove('visible');
    });
  }
}

/* ============================================
   SECTION 3: PROBLEM2 - CARD SCROLL ANIMATIONS
   ============================================ */

class Problem2Animations {
  constructor() {
    this.section = document.querySelector('#problem2');
    this.content = document.querySelector('.problem2-content');
    this.animation = document.querySelector('.problem2-animation');
    this.isVisible = false;

    if (this.section && (this.content || this.animation)) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showElements();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideElements();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showElements() {
    if (this.content) {
      this.content.classList.add('visible');
    }
    if (this.animation) {
      this.animation.classList.add('visible');
    }
  }

  hideElements() {
    if (this.content) {
      this.content.classList.remove('visible');
    }
    if (this.animation) {
      this.animation.classList.remove('visible');
    }
  }
}

/* ============================================
   SECTION 4: PROBLEM3 - CARD SCROLL ANIMATIONS
   ============================================ */

class Problem3Animations {
  constructor() {
    this.section = document.querySelector('#problem3');
    this.header = document.querySelector('.problem3-header');
    this.stats = document.querySelector('.problem3-stats');
    this.isVisible = false;

    if (this.section && (this.header || this.stats)) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showElements();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideElements();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showElements() {
    if (this.header) {
      this.header.classList.add('visible');
    }
    if (this.stats) {
      this.stats.classList.add('visible');
    }
  }

  hideElements() {
    if (this.header) {
      this.header.classList.remove('visible');
    }
    if (this.stats) {
      this.stats.classList.remove('visible');
    }
  }
}

/* ============================================
   SECTION 6: PROBLEM5 - TESTIMONIALS SCROLL ANIMATIONS
   ============================================ */

class Problem5Animations {
  constructor() {
    this.section = document.querySelector('.problem5-section');
    this.testimonials = document.querySelectorAll('.testimonial-item');
    this.isVisible = false;

    if (this.section && this.testimonials.length > 0) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showTestimonials();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideTestimonials();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showTestimonials() {
    this.testimonials.forEach(testimonial => {
      testimonial.classList.add('visible');
    });
  }

  hideTestimonials() {
    this.testimonials.forEach(testimonial => {
      testimonial.classList.remove('visible');
    });
  }
}

/* ============================================
   SECTION 5: PROBLEM4 - VALIDATION STATS SCROLL ANIMATIONS
   ============================================ */

class Problem4Animations {
  constructor() {
    this.section = document.querySelector('.problem4-section');
    this.stats = document.querySelectorAll('.validation-stat');
    this.isVisible = false;

    if (this.section && this.stats.length > 0) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showStats();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideStats();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showStats() {
    this.stats.forEach(stat => {
      stat.classList.add('visible');
    });
  }

  hideStats() {
    this.stats.forEach(stat => {
      stat.classList.remove('visible');
    });
  }
}

/* ============================================
   SECTION 8: SOLUTION2 - COMPARISON TABLE SCROLL ANIMATIONS
   ============================================ */

class Solution2Animations {
  constructor() {
    this.section = document.querySelector('.solution2-section');
    this.table = document.querySelector('.comparison-table');
    this.isVisible = false;

    if (this.section && this.table) {
      this.init();
    }
  }

  init() {
    const options = {
      root: null,
      rootMargin: '0px',
      threshold: 0.2
    };

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        if (entry.isIntersecting && !this.isVisible) {
          this.showTable();
          this.isVisible = true;
        } else if (!entry.isIntersecting && this.isVisible) {
          this.hideTable();
          this.isVisible = false;
        }
      });
    }, options);

    observer.observe(this.section);
  }

  showTable() {
    if (this.table) {
      this.table.classList.add('visible');
    }
  }

  hideTable() {
    if (this.table) {
      this.table.classList.remove('visible');
    }
  }
}

/* ============================================
   SECTION 3: PROBLEM2 - LOTTIE ANIMATION
   ============================================ */

// Inicializar animaÃ§Ã£o Lottie quando o DOM estiver pronto
function initProblem2Lottie() {
    const container = document.getElementById('problem2-lottie');

    if (!container) {
        console.warn('Problem2 Lottie container nÃ£o encontrado');
        return;
    }

    // Verificar se Lottie estÃ¡ carregado
    if (typeof lottie === 'undefined') {
        console.error('Lottie library nÃ£o estÃ¡ carregada');
        return;
    }

    try {
        // ConfiguraÃ§Ã£o da animaÃ§Ã£o Lottie usando lottie-web
        const animation = lottie.loadAnimation({
            container: container,
            renderer: 'svg', // Use SVG renderer for better quality
            loop: true,
            autoplay: true,
            path: './PATA.json' // Path to your PATA.json file
        });

        // Optional: Add intersection observer for performance
        const observer = new IntersectionObserver((entries) => {
            entries.forEach(entry => {
                if (entry.isIntersecting) {
                    animation.play();
                } else {
                    animation.pause();
                }
            });
        }, {
            threshold: 0.1
        });

        observer.observe(container);

        console.log('âœ… Problem2 Lottie animation loaded successfully');
        return animation;
    } catch (error) {
        console.error('âŒ Error loading Problem2 Lottie animation:', error);
    }
}

/* ============================================
   SMOOTH SCROLL - CUSTOM IMPLEMENTATION
   ============================================ */

class SmoothScroll {
  constructor() {
    this.scrollTarget = 0;
    this.scrollCurrent = 0;
    this.ease = 0.1;
    this.rafId = null;
    this.isRunning = false;
    this.isScrolling = false;
    this.scrollTimeout = null;
    this.init();
  }

  init() {
    try {
      // Set initial scroll position
      this.scrollCurrent = window.pageYOffset;
      this.scrollTarget = window.pageYOffset;

      // Handle wheel events for smooth mouse wheel scrolling
      this.handleWheel = this.handleWheel.bind(this);
      window.addEventListener('wheel', this.handleWheel, { passive: false });

      // Handle keyboard events (arrow keys, page up/down, etc.)
      this.handleKeyboard = this.handleKeyboard.bind(this);
      window.addEventListener('keydown', this.handleKeyboard, { passive: false });

      // Handle scrollbar dragging and other scroll events
      this.handleScroll = this.handleScroll.bind(this);
      window.addEventListener('scroll', this.handleScroll, { passive: true });

      // Handle anchor links
      this.setupAnchorLinks();

      // Start animation loop
      this.isRunning = true;
      this.raf();

      console.log('âœ¨ Smooth scroll initialized');
    } catch (error) {
      console.error('âŒ Error initializing smooth scroll:', error);
    }
  }

  handleWheel(e) {
    e.preventDefault();
    this.isScrolling = true;
    this.scrollTarget += e.deltaY;

    // Clamp scroll target to valid range
    const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
    this.scrollTarget = Math.max(0, Math.min(this.scrollTarget, maxScroll));

    // Reset scrolling flag after a delay
    clearTimeout(this.scrollTimeout);
    this.scrollTimeout = setTimeout(() => {
      this.isScrolling = false;
    }, 100);
  }

  handleKeyboard(e) {
    // Don't handle keyboard scrolling if user is typing in a form field
    const activeElement = document.activeElement;
    const isFormElement = activeElement && (
      activeElement.tagName === 'INPUT' ||
      activeElement.tagName === 'TEXTAREA' ||
      activeElement.tagName === 'SELECT' ||
      activeElement.isContentEditable
    );

    if (isFormElement) {
      return; // Allow default behavior for form inputs
    }

    // Handle arrow keys and page navigation
    const keyActions = {
      'ArrowDown': 100,
      'ArrowUp': -100,
      'PageDown': window.innerHeight * 0.8,
      'PageUp': -window.innerHeight * 0.8,
      'Home': -this.scrollTarget,
      'End': document.documentElement.scrollHeight - window.innerHeight - this.scrollTarget,
      ' ': window.innerHeight * 0.8 // Space bar
    };

    if (keyActions[e.key] !== undefined) {
      e.preventDefault();
      this.isScrolling = true;
      this.scrollTarget += keyActions[e.key];

      // Clamp scroll target to valid range
      const maxScroll = document.documentElement.scrollHeight - window.innerHeight;
      this.scrollTarget = Math.max(0, Math.min(this.scrollTarget, maxScroll));

      // Reset scrolling flag
      clearTimeout(this.scrollTimeout);
      this.scrollTimeout = setTimeout(() => {
        this.isScrolling = false;
      }, 100);
    }
  }

  handleScroll(e) {
    // Handle scrollbar dragging - update target to match actual scroll
    if (!this.isScrolling) {
      const currentScroll = window.pageYOffset;
      // Only update if there's a significant difference (user is dragging scrollbar)
      if (Math.abs(currentScroll - this.scrollCurrent) > 5) {
        this.scrollTarget = currentScroll;
        this.scrollCurrent = currentScroll;
      }
    }
  }

  setupAnchorLinks() {
    // Get all anchor links that point to sections on this page
    const anchorLinks = document.querySelectorAll('a[href^="#"]');

    anchorLinks.forEach(link => {
      link.addEventListener('click', (e) => {
        const href = link.getAttribute('href');

        // Skip empty or just # links
        if (href === '#' || href === '') return;

        const target = document.querySelector(href);
        if (target) {
          e.preventDefault();
          this.scrollTo(target.offsetTop);
        }
      });
    });
  }

  scrollTo(targetPosition) {
    this.isScrolling = true;
    this.scrollTarget = targetPosition;

    clearTimeout(this.scrollTimeout);
    this.scrollTimeout = setTimeout(() => {
      this.isScrolling = false;
    }, 100);
  }

  raf() {
    if (!this.isRunning) return;

    // Lerp (linear interpolation) for smooth scrolling
    this.scrollCurrent += (this.scrollTarget - this.scrollCurrent) * this.ease;

    // Round to avoid sub-pixel rendering issues
    const rounded = Math.round(this.scrollCurrent * 100) / 100;

    // Apply scroll
    window.scrollTo(0, rounded);

    // Continue animation loop
    this.rafId = requestAnimationFrame(() => this.raf());
  }

  destroy() {
    this.isRunning = false;
    if (this.rafId) {
      cancelAnimationFrame(this.rafId);
    }
    clearTimeout(this.scrollTimeout);
    window.removeEventListener('wheel', this.handleWheel);
    window.removeEventListener('keydown', this.handleKeyboard);
    window.removeEventListener('scroll', this.handleScroll);
  }
}

/* ============================================
   INITIALIZE ALL MODULES
   ============================================ */

document.addEventListener('DOMContentLoaded', () => {
  // Initialize Smooth Scroll
  const smoothScroll = new SmoothScroll();

  // Initialize Navbar
  new Navbar();

  // Initialize Header Parallax
  const headerParallax = new HeaderParallax();

  // Initialize Header Reveal Animations
  new HeaderAnimations();

  // Initialize Mouse Highlight
  const mouseHighlight = new MouseHighlight();

  // Initialize Draggable Element
  new DraggableElement();

  // Initialize Contact Buttons (pass smooth scroll instance)
  new ContactButtons(smoothScroll);

  // Initialize Scroll to Top Button (pass smooth scroll instance)
  window.scrollToTopButton = new ScrollToTopButton(smoothScroll);

  // Initialize Video Lazy Loader
  new VideoLazyLoader();

  // Initialize Problem1 Card Animations
  new Problem1Animations();

  // Initialize Problem2 Card Animations
  new Problem2Animations();

  // Initialize Problem3 Card Animations
  new Problem3Animations();

  // Initialize Problem4 Validation Stats Animations
  new Problem4Animations();

  // Initialize Problem5 Testimonials Animations
  new Problem5Animations();

  // Initialize Solution1 Card Animations
  new Solution1Animations();

  // Initialize Solution2 Table Animations
  new Solution2Animations();

  // Initialize Solution3 Card Animations
  new Solution3Animations();

  // Initialize Solution4 Card Animations
  new Solution4Animations();

  // Initialize JoinUs1 Card Animations
  new JoinUs1Animations();

  // Initialize JoinUs2 Card Animations
  new JoinUs2Animations();

  // Initialize Reservar Reveal Animations
  new ReservarAnimations();

  // Initialize JoinUs3 Stat Cards Animations
  new JoinUs3Animations();

  // Initialize Problem2 Lottie Animation
  initProblem2Lottie();

  // Cleanup on page unload (boa prÃ¡tica)
  window.addEventListener('beforeunload', () => {
    mouseHighlight.destroy();
    smoothScroll.destroy();
    headerParallax.destroy();
    if (window.scrollToTopButton) {
      window.scrollToTopButton.destroy();
    }
  });

  console.log('ðŸ¾ PATA Website - All modules initialized');
});

/* ============================================
   PERFORMANCE MONITORING
   ============================================ */

// Log performance metrics
window.addEventListener('load', () => {
  if (window.performance && window.performance.timing) {
    const perfData = window.performance.timing;
    const pageLoadTime = perfData.loadEventEnd - perfData.navigationStart;
    const connectTime = perfData.responseEnd - perfData.requestStart;
    const renderTime = perfData.domComplete - perfData.domLoading;

    console.log('âš¡ Performance Metrics:');
    console.log(`  Page Load: ${pageLoadTime}ms`);
    console.log(`  Connect: ${connectTime}ms`);
    console.log(`  Render: ${renderTime}ms`);
  }
});

})();

